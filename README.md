# Отчёт

## Постановка задачи

Минимум:

* Консольный (или другой пользовательский) интерфейс
* Парсер программ на языке из входного файла (можно пользоваться библиотеками)
* Преобразование из обычной записи в de Bruijn и locally-nameless
* Реализация одной из стратегий редукций
* Обработка ошибок
* Юнит-тесты

Дополнительные задачи:

* Добавить типизацию (любую на выбор)
* Сравнение нескольких стратегий редукций (качественно и количественно)
* Property-based тестирование

## Архитектура

Код для работы с лямбда-термами по большей части взят из соответствующего домашенего задания.
В нём есть три основных класса: `Lambda`, `DeBruijn` и `LocallyNameless`. Определены
переходы из первого в последние два, преобразование в строку для каждого из представлений, а также стратегии редукции и вспомогательные функции для них.

Затем я написал парсер для `Lambda`, который соответствует рекурсивному определению лямбда-термов, с некоторыми уточнениями.

Основное приложение считывает лямбда-терм из входного файла, используя этот парсер, затем вычисляет его до нормальной формы (либо не вычисляет, если пользователь настоял на применении applicative order и дал неудобный для него терм) и выводит все три представления
либо на экран, либо в указанный выходной файл. Настраивается поведение программы с помощью аргументов командной строки. Код этой части основан на коде с одной из практик.

К коду про лямбда-исчисление и парсеру есть юнит-тесты, для парсера есть ещё property-based тест на то, что `parseLambda` и `show` сочетаются.

## Выбор библиотек
Для разбора аргументов командной строки исползовал библиотеку `optparse-applicative`, потому что она уже использовалась в коде с практики, ну и в целом довольно удобна.

По тем же причинам для property-based теста я использовал `hedgehog`.

Для парсинга я взял `megaparsec`, хотя есть много других похожих библиотек, этот выбор был довольно случайным.